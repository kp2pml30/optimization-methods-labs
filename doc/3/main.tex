\documentclass[russian, english]{article}

\usepackage[T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[english, main=russian]{babel}
\usepackage{amsmath}
\usepackage{pgfplots}
\usepackage{graphicx}
\usepackage{csvsimple}
\usepackage{hyperref}
\usepackage{textgreek}
\usepackage{etoolbox}

\newtoggle{aftersection}
\preto{\section}{\filbreak\global\toggletrue{aftersection}}
\preto{\subsection}{\iftoggle{aftersection}{\global\togglefalse{aftersection}}{\filbreak}}
\newcommand{\clearpageafterfirst}{%
  \gdef\clearpageafterfirst{\clearpage}%
}

\DeclareUnicodeCharacter{0394}{Delta}
\DeclareUnicodeCharacter{03B5}{epsilon}

\inputencoding{utf8}
\def\code#1{\texttt{#1}}
\newcommand{\mydot}[2]{\left\langle#1,#2\right\rangle}

\newcommand{\FastTable}[1]{
	\begin{center}
	\csvautotabular[separator=tab]{#1}
	\end{center}
}

\begin{document}
\begin{titlepage}
\centering
	{\scshape\LARGE Методы оптимизации \par}
	\vspace{1cm}
	{\scshape\Large Лабораторная работа №3\par}
	\vspace{2cm}
	{\Large\itshape Дмитрий Проценко M3234 \par
	Кирилл Прокопенко M3236 \par
	Николай Холявин M3238 \par}
	\vfill
	ИТМО y2019
	\vfill
	{\large \today\par}
\end{titlepage}

\tableofcontents
\newpage

\section{Цели}
\begin{itemize}
	\item реализовать $LU$ разложение и решение систем линейных уравнений на его основе
	\item оценить зависимость погрешности от числа обусловленности, размерности (на сгенерированных матрицах с диагональным преобладанием, матрицах Гильберта)
	\item сравнить с другими методами (Гаусса)
	\item реализовать разреженные профильный и разреженный строчно-столбцевой симметричный форматы хранения матриц
	\item реализовать и оценить метод сопряженных градиентов для решения систем линейных уравнений
\end{itemize}
\section{Теория}
\subsection{Обозначения}
Рассматривается решение системы $Ax=f$ \\
$\|\cdot\|$ --- Евклидова норма
\subsection{Разреженный профильный формат матрицы}
Данный формат позволяет хранить квадратные матрицы: отдельно хранится главная диагональ и 2 треугольника, при этом треугольники хранятся в следующем формате: нижний левый хранится по строкам, верхний правый по столбцам, индексы первых ненулевых элементов соответствующих линий совпадают. Для улучшения кэширования и уменьшения фрагментации памяти каждый треугольник имеет общую память.\\
Это может выглядеть, например, так:

\newcommand*{\GridSize}{8}

\newcommand*{\ColorCells}[1]{% #1 = list of x/y/color
	\foreach \x/\y/\color in {#1} {
		\node [fill=\color, draw=none, thick, minimum size=1cm] 
			at (\x-.5,\GridSize+0.5-\y) {};
	}
}

\newcommand*{\ColorCellsdxdy}[4]{% #4 = list of x/y/color
	\foreach \myi in {1,...,#1}{
		\foreach \x/\y/\color in {#4} {
			\node [fill=\color, draw=none, thick, minimum size=1cm] 
				at (\myi*#2-#2+\x-.5,\myi*#3-#3+\GridSize+0.5-\y) {};
		}
	}
}
\begin{center}
\begin{tikzpicture}[scale=1]
	\begin{scope}[thick,local bounding box=name]
		% \ColorCells{1/1/blue, 2/3/red, 3/2/green, 4/4/yellow}
		\ColorCellsdxdy{\GridSize}{1}{-1}{1/1/red}
		\ColorCellsdxdy{3}{1}{0}{2/5/blue}
		\ColorCellsdxdy{3}{0}{-1}{5/2/blue}
		\ColorCellsdxdy{5}{1}{0}{1/6/green}
		\ColorCellsdxdy{5}{0}{-1}{6/1/green}
		\ColorCellsdxdy{2}{1}{0}{6/8/purple}
		\ColorCellsdxdy{2}{0}{-1}{8/6/purple}
		\draw (0, 0) grid (\GridSize, \GridSize);
	\end{scope}
\end{tikzpicture}
\end{center}
Белые клетки --- нули, красные --- диагональ, одинаковые цвета показывают соответствующие профили матрицы.\par
Данное представление хорошо подходит для $LU$ разложения, поскольку в его алгоритме вычисляются скалярные произведения строк на столбцы с равными индексами. Такой формат минимизирует число перемножений нулей и является оптимальным по кэшу для описанной операции.

\subsection{Разреженный строчно-столбцевой формат матрицы}
Данный формат позволяет хранить квадратные матрицы: отдельно хранится главная диагональ и 2 треугольника, при этом треугольники хранятся в следующем формате: нижний левый хранится по строкам (разреженно), верхний правый по столбцам (разреженно), индексы ненулевых элементов соответствующих линий совпадают. Для улучшения кэширования и уменьшения фрагментации памяти каждый треугольник имеет общую память. Также для обеспечения работы для каждого элемента из строки (столбца) хранится номер соответствующего столбца (строки), чем достигается большая разреженность.\\
Это может выглядеть, например, так:
\begin{center}
\begin{tikzpicture}[scale=1]
	\begin{scope}[thick,local bounding box=name]
		% \ColorCells{1/1/blue, 2/3/red, 3/2/green, 4/4/yellow}
		\ColorCellsdxdy{\GridSize}{1}{-1}{1/1/red}
		\ColorCellsdxdy{1}{1}{0}{2/5/blue}
		\ColorCellsdxdy{1}{1}{0}{4/5/blue}
		\ColorCellsdxdy{1}{0}{-1}{5/2/blue}
		\ColorCellsdxdy{1}{0}{-1}{5/4/blue}
		\ColorCellsdxdy{1}{1}{0}{1/6/green}
		\ColorCellsdxdy{2}{1}{0}{4/6/green}
		\ColorCellsdxdy{1}{0}{-1}{6/1/green}
		\ColorCellsdxdy{2}{0}{-1}{6/4/green}
		\ColorCellsdxdy{2}{1}{0}{6/8/purple}
		\ColorCellsdxdy{2}{0}{-1}{8/6/purple}
		\draw (0, 0) grid (\GridSize, \GridSize);
	\end{scope}
\end{tikzpicture}
\end{center}
Белые клетки --- нули, красные --- диагональ, одинаковые цвета показывают соответствующие профили матрицы.\par
Такой формат похож на профильный, но хранит строки более разреженно и используется для минимизации операций при перемножении матрицы на вектор, что необходимо для метода сопряжённых градиентов.
\subsection{Метод Гаусса с выбором главного элемента}
Скорее всего, всем ещё со школы знаком обычный метод Гаусса преобразования матрицы к треугольной форме. Модификация метода Гаусса заключается в оптимальном выборе очередной строки для вычитаний. Для увеличения точности операций происходит поиск максимального по модулю элемента в текущем столбце и перемена мест текущей строчки и строчки, соответствующей найденному элементу (строки матрицы и элемента вектора свободных коэффициентов). Таким образом при вычислении коэффициентов для зануления элементов ниже главной диагонали произойдёт деление на максимально возможный элемент.

\subsection{$LU$ разложение}

\def\opn#1{\operatorname{#1}}
\newcommand{\mtop}[1]{%
\begin{tikzpicture}[#1]%
\draw (0,1.5ex) -- (1.5ex,0);%
\draw (1.5ex,0) -- (1.5ex,1.5ex);%
\draw (0,1.5ex) -- (1.5ex,1.5ex);%
\end{tikzpicture}%
}

\newcommand{\mbottom}[1]{%
\begin{tikzpicture}[#1]%
\draw (0,0) -- (1.5ex,0);%
\draw (1.5ex,0) -- (0,1.5ex);%
\draw (0,0) -- (0,1.5ex);%
\end{tikzpicture}%
}

$A=LU$\\
$U = \mtop{}$, \textbf{не} включает диагональ\\
$L = \mbottom{}$, включает диагональ\\
$L_{1, 1} = A_{1, 1}$\\
$\forall i:\; U_{i, i} = 1$\\
$\forall i\in\overline{2\dots n}: \forall j\in\overline{1\dots i-1}:$
$\begin{cases}
	L_{i,j} = A_{i, j} - \mydot{\opn{row}_L(i)}{\opn{col}_U(j)}\\
	U_{j,i} = \frac{A_{i, j} - \mydot{\opn{row}_L(j)}{\opn{col}_U(i)}}{L_{j, j}}\\
\end{cases}$\\

Для оптимизации объема выделяемой памяти результат складывается в матрицу $A$. Это возможно, поскольку на каждом шаге мы используем только ``старые'' значения матриц $L$ и $U$ и текущее значение матрицы $A$. Профильный формат хранения матрицы позволяет ``обрезать'' нули по краям строк и столбцов.

\section{Метод $LU$-разложения}
\subsection{Диагональное преобладание}
\label{DiagonalPrMatrix0}
Исследуем зависимость погрешности от числа обусловленности ($k$) и размерности пространства ($n$). Для этого будем генерировать матрицы коэффициентов за счет изменения диагонального преобладания для систем вида $A_kx_k=f_k$ следующим образом:\\
$\forall i\neq j:\; A_{i, j}\in\left\{0, -1, -2, -3, -4\right\}$\\
$A_{i,i}=\begin{cases}
-\sum_{i\neq j}A_{i, j} & i > 1\\
-\sum_{i\neq j}A_{i, j} + 10^{-k} & i = 1\\
\end{cases}$\\
Для оценки погрешности будем генерировать системы с заранее известным ответом: $f_k=A_k\cdot (1,\dots,n)^T$\\

\FastTable{test/out/diag/LU.tsv}

Можно заметить, что погрешность крайне мала, что неудивительно, ведь мы находим точное решение. Она практически не зависит от $k$: порядок числа не меняется, числа находятся в диапазоне минимальных представимых в использованных типах. С изменением размерности пространства погрешность растет более существенно, что связано просто с тем как работает дробная арифметика на ЭВМ, ведь периодические дроби непредставимы в типе \texttt{double}.

\subsection{Матрицы Гильберта}
\label{Hilbert}
$\forall i,j\in\overline{1\dots n}:\; A_{i,j}=\frac{1}{i+j-1}$

Они являются плохо обусловленными: их число обусловленности растет как $\mathcal{O}\left(\frac{(1+\sqrt{2})^{4n}}{\sqrt{n}}\right)$ согласно Википедии.\\

\FastTable{test/out/hilbert/LU.tsv}

Стоит понимать, что от порядка операций зависит точность: рассмотрим массив $a[i] = \frac{1}{i}$. Его левая свертка по сложению является менее точной, чем правая.

\section{Метод Гаусса}
\subsection{Диагональное преобладание}
\hyperref[DiagonalPrMatrix0]{Определение было дано выше}.
\FastTable{test/out/diag/Gauss.tsv}
\subsection{Матрицы Гильберта}
\hyperref[Hilbert]{Определение было дано выше}.
\FastTable{test/out/hilbert/Gauss.tsv}

Можно заметить, что погрешность оказалась меньше. Это происходит потому, что число обусловленности матриц Гильберта очень велико, а метод Гаусса с выбором главного элемента является более вычислительно устойчивым, чем метод $LU$-разложения.

\section{Скачкообразная погрешность}
Была исследована последовательность систем линейных уравнений с матрицами с диагональным преобладанием, соответствующими данному выше определению, с параметром $k=0$.

\begin{tikzpicture}[trim axis left]
	\begin{axis}[
		scale only axis,
		width=\textwidth,
		legend style={at={(0.5,-0.1)},anchor=north},
		xlabel = {n},
		ylabel = {погрешность},
	]
		\addplot+[mark=none] table [x={n}, y={Delta}] {test/out/diagSkak/LU.tsv};
		\addlegendentry{LU}
		\addplot+[mark=none] table [x={n}, y={Delta}] {test/out/diagSkak/Gauss.tsv};
		\addlegendentry{Гаусс}
	\end{axis}
\end{tikzpicture}
Можно видеть, что при определённых значениях $n$ (порядка 190, 370, 520, 730 и т.д.) происходят скачки накопленной погрешности. Вероятно, это происходит из-за особенностей внутренней структуры матрицы с диагональным преобладанием и соответствующих округлений на каждой итерации алгоритма метода Гаусса.

\section{Метод сопряженных градиентов}
В исследовании работы данного метода из матриц используются только несколько диагоналей (главная и восемь) для получения разреженных матриц и возможности протестировать алгоритм на размерностях порядка $10^5$.

\subsection{Алгоритм}
\begin{itemize}
	\item[обозначение] $\forall v:\; v^2\equiv \mydot{v}{v}$
	\item[подготовка]
		\begin{enumerate}
			\item выберем начальное приближение $x_0$, например, из всех единиц
			\item $r_0 = f - Ax_0$
			\item $z_0 = r_0$
		\end{enumerate}
	\item[цикл]
		\begin{enumerate}
			\item $\alpha_k=\frac{r_{k-1}^2}{\mydot{Az_{k-1}}{z_{k-1}}}$
			\item $x_k=x_{k-1}+\alpha_kz_{k-1}$
			\item $r_k=r_{k-1}-\alpha_kAz_{k-1}$
			\item $\beta_k=\frac{r_k^2}{r_{k-1}^2}$
			\item $z_k=r_k+\beta_kz_{k-1}$
		\end{enumerate}
\end{itemize}
\subsection{Матрица с диагональным преобладанием, версия 1}
\label{DiagonalPrMatrix}
$\forall i\neq j:\; A_{i, j}\in\left\{0, -1, -2, -3, -4\right\}$\\
$A_{i,i}=\begin{cases}
-\sum_{i\neq j}A_{i, j}, & i > 1\\
-\sum_{i\neq j}A_{i, j} + 1, & i = 1\\
\end{cases}$\\
$\operatorname{cond}(A) \ge \frac{\|x-x^*\|}{\|x^*\|}\div\frac{\|f-Ax\|}{\|f\|}$, первая дробь --- относительная погрешность, вторая --- невязка.
\FastTable{test/out/conj_diag/ConjGrad.tsv}

\subsection{Матрица с диагональным преобладанием, версия 2}
$\forall i\neq j:\;A_{i, j}\leftarrow -A_{i, j}$, из \hyperref[DiagonalPrMatrix]{первой версии}.
\FastTable{test/out/conj_diag_rev/ConjGrad.tsv}

\subsection{Плотная матрица Гильберта}
Определение было дано \hyperref[Hilbert]{выше}.\\
\FastTable{test/out/conj_hilbert/ConjGrad.tsv}

Так как числа обусловленности матриц Гильберта растут очень быстро и уже очень велики на $n=10$, то соответствующие нижние оценки не могут быть посчитаны точно и несут мало информации.

\section{Сравнение количества действий}

\def\makePlots#1#2#3{
		\addplot+[mark=#3] table [x={n}, y={i}] {#1};
		\addlegendentry{#2}
}

\begin{minipage}{\textwidth}
Для сравнения будем использовать плотные матрицы Гильберта, чтобы не было случайности и оптимизации из-за профильного формата хранения. Каждая операция считается за единицу, разное количество реальных тактов не учитывается. Для замера был реализован класс, перед каждой операцией увеличивающий соответствующий счетчик с возможностью сбора статистики по операциям.

\begin{tikzpicture}[trim axis left]
	\begin{axis}[
		scale only axis,
		width=\textwidth,
		legend style={at={(0.5,-0.1)},anchor=north},
		xlabel = {n},
		ylabel = {число действий},
	]
		\makePlots{test/out/complexity_hilbert/LU.tsv}{LU}{square}
		\makePlots{test/out/complexity_hilbert/Gauss.tsv}{Гаусс}{x}
		\addplot[domain=0:1234] {x^3 * 0.670314};
		\addlegendentry{$0.670314x^3$ -- линия тренда для метода Гаусса}
		\makePlots{test/out/complexity_hilbert/ConjGrad.tsv}{Метод сопряженных градиентов}{square*}
	\end{axis}
\end{tikzpicture}
\end{minipage}

При проведении теоретических подсчётов можно установить, что количество операций над числами с плавающей точкой в методах Гаусса и LU-разложения эквивалентно $\frac{2}{3}n^3$ при $n \rightarrow \infty$. Эта функция, как видно из графика, и является линией тренда для экспериментально посчитанных значений (коэффициент $0.67$).

\begin{minipage}{\textwidth}
Теперь рассмотрим матрицы с несколькими диагоналями, построенные при помощи диагонального преобладания. Гаусс вне конкуренции: он не использует разреженность матрицы и его время работы не изменится.

\begin{tikzpicture}[trim axis left]
	\begin{axis}[
		scale only axis,
		width=\textwidth,
		legend style={at={(0.5,-0.1)},anchor=north},
		xlabel = {n},
		ylabel = {число действий},
	]
		\makePlots{test/out/complexity_sparse/LU.tsv}{LU}{square*}
		\makePlots{test/out/complexity_sparse/ConjGrad.tsv}{Метод сопряженных градиентов}{*}
	\end{axis}
\end{tikzpicture}
\end{minipage}

Можно увидеть, что метод сопряжённых градиентов работает быстрее и на плотных, и на разреженных протестированных матрицах. Для разреженных матриц с диагональным преобладанием это связано с тем, что при ограниченном числе обусловленности метод сопряжённых градиентов совершает линейное от размерности число действий. Для плотных матриц Гильберта метод сопряжённых градиентов получает решение быстрее, однако менее точно, чем прямые методы.

\section{Вывод}
В ходе работы была реализована библиотека методов решения систем линейных уравнений (метод $LU$-разложения, метод Гаусса, метод сопряжённых градиентов), матриц с различными форматами хранения (плотные матрицы, разреженные профильные и разреженные строчно-столбцовые), генерации матриц различного вида (матриц Гильберта, матриц с диагональным преобладанием) в перечисленных форматах. Также была исследована зависимость точности, числа итераций от размерности пространства и числа обусловленности, была дана оценка методов по сравнению друг с другом. Полученные результаты были обоснованы на основании изученной теории. \\\\
Метод $LU$-разложения позволяет совершать меньше действий на разреженных матрицах, чем метод Гаусса, однако уступает в вычислительной устойчивости, что может иметь большие погрешности на матрицах с большими числами обусловленности. Метод сопряженных градиентов имеет меньшее число итераций на исследованных матрицах по сравнению с прямыми методами, однако может давать менее точный результат на плохо обусловленных матрицах. Такая проблема решается, например, предобусловливанием системы.


\newpage
\appendix
\section{Код}
Код матриц, $LU$ разложения и вся математика находится в директории \texttt{include/math} под говорящими названиями.
\subsection{Ссылки}
\url{https://github.com/kp2pml30/optimization-methods-labs}
\end{document}

